##### java接口成员变量和方法默认修饰符(缺省属性)

1. ​	成员变量默认修饰符：public static final
2. ​    成员方法默认修饰符：public abstract

接口只是对一类事物属性和行为的更高层次抽象；对修改关闭，对拓展开放，可以说是java中开闭原则的一种体现

简单的理解，定义接口的目的地是为了解决Java无法使用多继承的一种手段，也可以把接口理解成是一种特殊的abstract类。

##### 重载和重写

重载：1.在同一个类中；方法名相同，参数列表不同；和返回值无关

重写：1.不在同一个类中，且必须有继承关系；方法名、参数都相同

​			   返回类型要么和父类的返回类型一致，要么子类返回类型是父类方法返回值类型的子类

​				访问修饰符要么相同，要么子类访问的修饰符范围大于父类

##### String、StringBuffer、StringBuilder区别

String 字符串常量不可变，使用字符串拼接时会开辟新空间

StringBuffer 字符串变量线程安全 字符串拼接直接在字符串后追加

StringBuilder字符串变量非线程安全 字符串拼接直接在字符串后追加

Stringbuilder > StringBuffer > String

StringBuilder的速度快是因为它是按照字节数组存储的 拼接字符串时 只需要将数组扩容添加即可

而String变量是不可变的 每次拼接都需要开辟一块新的空间 重新放置  比较费时间

##### 单例设计模式

单例就是该类只能返回一个实例。

单例特点：

1. 私有化的构造函数
2. 私有的静态的全局变量
3. 公有的静态的方法

##### 基础知识

1. 所有的class都必须有一个构造方法，如果你没有再代码里声明构造方法，系统会自动生成一个公有无参的构造方法。而只要你自己声明了一个构造方法，无论有参无参，私有，西永就不再帮你生成默认无参构造器了。
2. 所有的子类构造器都要求再第一行代码中调用父类构造器，如果不写，系统默认调用无参构造器。

##### 抽象类是否可以继承实体类

抽象类可以继承实体类，但前提是实体类必须有明确的构造方法。

也就是说 “可以继承，但是和实体类的继承一样，也要求父类可继承，并且拥有子类可访问到的构造器”。

##### 子类为什么要调用父类的构造函数

在Java中，子类的构造过程中，必须调用其父类的构造函数。所以说，子类对象比父类对象大，子类对象里面包含了一个父类的对象，这是内存中真是的情况。构造方法是new一个对象的时候，必须要调的方法，这是规定，要new父类对象出来，那么肯定要调用其构造方法，所以第一个规则：子类的构造过程中，必须调用其父类的构造方法一个类，如果我们不写构造方法，那么编译器回帮我们加上一个默认的构造方法，所谓默认的构造方法，就是没有参数的构造方法，但是如果你自己写了构造方法，那么编译器就不会给你添加了  所以有时候当你new一个子类对象的时候，肯定调用了子类的构造方法，但是在子类构造方法中我们并没有显示的调用基类的构造方法，就是没写。但是第二个规则：如果子类的构造方法中没有显示的调用基类构造方法，则系统默认调用基类无参数的构造方法。

注意：如果子类的构造方法中既没有显示的调用基类构造方法，而基类中又没有默认无参的构造方法，则编译出错，所以，通常我们需要显示的：super(参数列表)，来调用父类有参数的构造函数。

##### 创建线程的4种方式

1. 继承Thread类实现多线程
2. 实现Runnable()接口实现多线程，而后同样覆盖run()  推荐此方式。
   - 覆盖Runnable接口实现多线程可以避免单继承局限
   - 当子类实现Runnable接口，此时子类和Thread的代理模式(子类负责真实业务的操作，Thread负责资源调度与线程创建辅助真实业务)
3. 覆盖Callabl接口实现多线程(JDK1.5)
   - 核心方法叫call() 方法，有返回值
   - 有返回值
4. 

  继承Thread和实现Runnable接口的区别

- 实现Runnable金额口避免多继承局限
- 实现Runnable()可以更好的体现共享的概念

##### Final关键字的作用

- 修饰类： （最终类）不能被子类继承
- 修饰方法：（最终方法）不能被子类重写
- 修饰变量：（常量）一旦声明之后，不能再次修改其中的值

